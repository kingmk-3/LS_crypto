from sympy.ntheory.factor_ import totient
from sympy import mod_inverse

#Using the data from ?????.py 
list_n = [2140324650240744961264423072839333563008614715144755017797754920881418023447140136643345519095804679610992851872470914587687396261921557363047454770520805119056493106687691590019759405693457452230589325976697471681738069364894699871578494975937497937, 
          124620366781718784065835044608106590434820374651678805754818788883289666801188210855036039570272508747509864768438458621054865537970253930571891217684318286362846948405301614416430468066875699415246993185704183030512549594371372159029236099,  
          115792089237316195423570985008687907853269984665640564039457584007913129639937,  
          69203410113561398433978337198079999737]

list_e = [1, 3, None, None]
list_d = [1, 
          27693414840381952014630009912912575652182305478150845723293064196286592622486269078896897682282779721668858837430768582289067861521354636766450456684327039016976994178279719950606433379665781300071586068259742625912915848683932903000406697, 
          77266263685307006230322907286315353524856777913832852852497884154975370477569, 
          56758248688344445618535855545843339303]
#note the value of list_d[1] is easy to obtain from mod_inverse
list_phi = [2140324650240744961264423072839333563008614715144755017797754920881418023447140136643345519095804679610992851872470914587687298754604485313310619754320029186553180340912603879017884504312838403856515485700993615480396424774279472227006542299206581860,
            124620366781718784065835044608106590434820374651678805754818788883289666801188210855036039570272508747509864768438458620300805376846095865449027055079471675576396473802258739777728950208496015850322137307168841816608121319077698063501830136,
            115792089237316101961931269650710138689711785058743979988220041130798187806720,
            68940279276627704903811119185919999476]
list_d[1]=mod_inverse(list_e[1],list_phi[1])%list_phi[1]
# Compute the missing e values using the given formula (e**i) * d == 1 (mod Ï†)
for i in range(1, 4):
    list_e[i] = mod_inverse(list_d[i], list_phi[i]) **(1/(i)) % list_phi[i]
list_e[3]=524287
list_e[2]=65537
list_e[1]=3
# Output to verify the computed e values
# print(list_e)
list_d1=[None]*4
for i in range(0, 4):
    list_d1[i] = mod_inverse(list_e[i], list_phi[i])%list_phi[i]
# print(list_d1)
# Decrypted cipher_1 values
output = [12331, 329796147429, 74123515046928094799825188664648897435800820530055170843191646450844356103736, 43902742405476161131473929002315604273, 
          12944, 27735580683, 78973387595019170784612458521728960323264867786515401685321385965026793856403, 31919992337066015048720993940025631713, 
          2347, 734847565824, 101271357811948351746604313864755895370188204420625050803278149660722073946239, 56349663930743838272275153491291168002, 
          8982, 2328310511064, 106058552522508819565468995006183368211991722056203258411598135921256264292248, 51792942655418674841644497405567291075, 
          11875, 384399163511, 35616979992135835717966741760639566123331219536421186604525024997159995343459, 40823011766295422493409073278264153576, 
          9039, 1129412837944, 49932432102491735682672329915063718414997565757845935029236989016277672292325, 13039422778599220469692552984865152667, 
          9053, 2181825073000, 84112885952588821792250635403984208020788974809389408663739568743119424997740, 30474861076101697076037209063127855525, 
          10835, 2430426096125, 11951553580270835032619325940480717483281377890052128849411588756090281688706, 63745756952654317830500039851174786720]

cipher_1_decrypted = [pow(output[i], list_d1[i % 4], list_n[i % 4]) for i in range(len(output))]

# print(cipher_1_decrypted)

def reverse_Riddler_XOR(cipher_1, length):
    flag_chars = [None] * length
    flag_chars[0]='Y'
    flag_chars[1]='o'
    flag_chars[2]='S'
    # print(flag_chars)
    i=3
    # print(length)#
    while i < length :
        a=flag_chars[i-2]
        b=flag_chars[i-1]
        # print(a,b,i)#
        for c in range(128):
            if (ord(a) ^ ord(b) * ord(b) ^ c) == cipher_1[i-2]:
                flag_chars[i] = chr(c)
                # print(c)#
                break
        i+=1
        # print(i)
        # print(flag_chars)#
    return ''.join(filter(None, flag_chars))
# Reconstruct the flag
flag = reverse_Riddler_XOR(cipher_1_decrypted, len(output))
print(flag)